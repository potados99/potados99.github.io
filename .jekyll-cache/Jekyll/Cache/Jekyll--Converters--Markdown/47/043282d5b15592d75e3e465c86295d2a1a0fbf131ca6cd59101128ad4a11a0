I"Y1<p>안드로이드에서 많이 쓰이는 디자인 중 하나는 tab based, 즉 탭 기반 방식이다.</p>

<p><img src="/assets/images/tab-based-app.jpg" alt="탭 기반 앱" /></p>

<blockquote>
  <p>대표적인 탭 기반 애플리케이션인 유튜브. 사진은 4년 전 것이긴 하지만 지금도 탭 기반인 건 변함이 없다.
카카오톡의 경우도 탭 기반 앱이다.</p>
</blockquote>

<p>거의 대부분의 앱이 이렇게 디자인되었으며, RecyclerView와 같은 목록 형태의 컨텐츠와 탭의 조합은 최고이다.</p>

<p>안드로이드에서 tab을 구현하는 방법 중 하나는 BottomNavigationView를 이용하는 것이다.
이는 구글이 요즘 밀어주는 <a href="https://material.io/design/">Material</a>의 컴포넌트 중 하나이다.</p>

<p><img src="https://storage.googleapis.com/spec-host-backup/mio-design%2Fassets%2F1h5m0BGM_LfXii-6hO4JisEM0bcWvG0Gl%2Fbottomnav-usage-1.png" alt="material" /></p>
<blockquote>
  <p>이렇게 생겼다. 그냥 탭이다.</p>
</blockquote>

<h2 id="탭-전환하기">탭 전환하기</h2>

<p>서론이 길었는데, 아무튼 탭이 있어야 하고, 탭 사이의 전환도 있어야 한다.</p>

<p>안드로이드에는 Fragment라는 좋은게 있으니까, 하나의 프래그먼트가 하나의 탭을 대표하도록 만들면 된다.</p>

<p>그리고 탭이 눌리면 그에 맞는 프래그먼트를 띄워주면 된다.</p>

<p>이 프래그먼트가 위치할 곳은 메인 액티비티에 있는 FrameLayout이다.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;FrameLayout</span>
        <span class="na">android:layout_width=</span><span class="s">"0dp"</span>
        <span class="na">android:layout_height=</span><span class="s">"0dp"</span>
        <span class="err">...constraints...</span>
        <span class="na">android:id=</span><span class="s">"@+id/fragment_container"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/FrameLayout&gt;</span>
</code></pre></div></div>

<p>그리고 어떤 탭이 눌렸을 때에 프래그먼트를 바꾸도록 리스너를 등록해주면 된다.</p>

<p>문제는 여기서 일어난다.</p>

<p>다음은 프래그먼트를 바꾸는 코드이다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">fragment</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span>

<span class="n">supportFragmentManager</span>
<span class="p">.</span><span class="nf">beginTransaction</span><span class="p">()</span>
<span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">fragment_container</span><span class="p">,</span> <span class="n">fragment</span><span class="p">)</span>
<span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
</code></pre></div></div>

<p>바뀌기는 잘 바뀌는데 두 가지 문제가 있었다.</p>

<p>하나는 BottomSheet의 상태가 보존되지 않는 것이었고, 다른 하나는 AppBarLayout과 RecyclerView, 그리고 BottomNavigationView를 사용하는 프래그먼트에서 리사이클러뷰가 끝까지 스크롤이 안되는 문제였다.</p>

<p><img src="/assets/images/scroll-problem.png" alt="스크롤이 안돼.." /></p>
<blockquote>
  <p>더이상 스크롤이 안된다. 아직 끝이 아닌데..</p>
</blockquote>

<h2 id="삽질">삽질</h2>

<p>맨 처음 앱을 띄우고 아무것도 안한 상태, 즉 프래그먼트를 처음 올린 상태에서는 스크를이 끝까지 잘 된다.</p>

<p>그런데 다른 프래그먼트로 교체 -&gt; 다시 첫번쨰 프래그먼트로 교체의 과정을 지나면 레이아웃이 살짝 버벅이면서 저렇게 스크롤이 안되는 상태가 되었다.</p>

<h3 id="분석">분석</h3>

<p>프래그먼트의 <code class="highlighter-rouge">onResume</code>에 리사이클러뷰 어댑터의 데이터 소스(LiveData)를 업데이트하는 코드를 넣으면 생명주기의 다른 콜백이 아닌 <code class="highlighter-rouge">onResume</code>만 실행될 때에(예를 들어 새로운 액티비티를 띄웠다가 닫을 때) 문제가 해결되는 것을 발견했다.</p>

<p>특이한 점이 하나 있었다.</p>

<p>프래그먼트를 완전히 교체하여 <code class="highlighter-rouge">onPause</code> -&gt; … -&gt; <code class="highlighter-rouge">onDetach</code>를 거쳐 다시 액티비티에 붙으면서 <code class="highlighter-rouge">onAttach</code> -&gt; … -&gt; <code class="highlighter-rouge">onResume</code>로 진행하는 과정에서는 <code class="highlighter-rouge">onResume</code>이 분명히 실행되는데도 불구하고 그렇지 않은 것처럼 동작했다.</p>

<h3 id="시도-1">시도 1</h3>

<p>원인은 알아내지 못했다. 이것저것 실험해보면 알 수도 있을테지만 사실 귀찮다.</p>

<p>일단 프래그먼트를 교체하기 전에는 문제가 발생하지 않는다.</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">fragment_container</span><span class="p">,</span> <span class="n">fragment</span><span class="p">)</span>
</code></pre></div></div>

<p>저 <code class="highlighter-rouge">replace</code>가 일어나기 전까지는 괜찮은 것이다.</p>

<p>그래서 <a href="https://stackoverflow.com/a/45301078">스택 오버플로우</a>를 잘 뒤져서 프래그먼트를 바꾸는 다른 방법을 찾아냈다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FragmentTransaction</span> <span class="n">fragmentTransaction</span> <span class="o">=</span> <span class="n">mFragmentManager</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">();</span>

<span class="nc">Fragment</span> <span class="n">curFrag</span> <span class="o">=</span> <span class="n">mFragmentManager</span><span class="o">.</span><span class="na">getPrimaryNavigationFragment</span><span class="o">();</span>
<span class="k">if</span> <span class="o">(</span><span class="n">curFrag</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">fragmentTransaction</span><span class="o">.</span><span class="na">detach</span><span class="o">(</span><span class="n">curFrag</span><span class="o">);</span>
<span class="o">}</span>

<span class="nc">Fragment</span> <span class="n">fragment</span> <span class="o">=</span> <span class="n">mFragmentManager</span><span class="o">.</span><span class="na">findFragmentByTag</span><span class="o">(</span><span class="n">tag</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">fragment</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">fragment</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">YourFragment</span><span class="o">();</span>
    <span class="n">fragmentTransaction</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">container</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">fragment</span><span class="o">,</span> <span class="n">tag</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">fragmentTransaction</span><span class="o">.</span><span class="na">attach</span><span class="o">(</span><span class="n">fragment</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">fragmentTransaction</span><span class="o">.</span><span class="na">setPrimaryNavigationFragment</span><span class="o">(</span><span class="n">fragment</span><span class="o">);</span>
<span class="n">fragmentTransaction</span><span class="o">.</span><span class="na">setReorderingAllowed</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="n">fragmentTransaction</span><span class="o">.</span><span class="na">commitNowAllowingStateLoss</span><span class="o">();</span>
</code></pre></div></div>

<p>현재 떠있는 프래그먼트를 가져와서 <code class="highlighter-rouge">detach</code>한다. 그리고 새로 집어넣을 프래그먼트의 레퍼런스를 잡아서 <code class="highlighter-rouge">attach</code>한다.</p>

<p>사실 replace와 별반 다르지 않다. 프래그먼트를 지우지 않고 잠깐 떼어낸다는 점이 다를 뿐이다.</p>

<blockquote>
  <p>using show hide instead of attach detach works better. It won’t restart fragment’s lifecycle – <a href="https://stackoverflow.com/users/1120126/osrl">osrl</a></p>
</blockquote>

<p>스택 오버플로우에 이런 댓글이 있었다.</p>

<p>생명주기를 보존하고 빠른 전환을 하기 위해 <code class="highlighter-rouge">show</code>와 <code class="highlighter-rouge">hide</code>를 사용할 수 있다.
프래그먼트에 손대지 않고 잠깐 숨겨주는 방법으로 넘어가기로 했다.</p>

<h3 id="시도-2">시도 2</h3>

<p><code class="highlighter-rouge">replace</code>의 기본 동작 다음과 같다.</p>
<blockquote>
  <p>해당 컨테이너의 id로 등록된 모든 fragment를 지우고 새 fragment를 추가한다.</p>
</blockquote>

<p><code class="highlighter-rouge">remove</code>와 <code class="highlighter-rouge">add</code>를 거치는 동안에는 프래그먼트의 생명주기가 새로 시작되므로 모든 초기화가 새로 일어난다. 이는 원하는 동작이 아니다.</p>

<p>프래그먼트가 전환되는 동안에도 메모리에 보존되어야 하며, 전환이 일어나도 초기화가 다시 일어나지 않아야 한다.</p>

<p><code class="highlighter-rouge">FragmentTransaction.show()</code>와 <code class="highlighter-rouge">FragmentTransaction.hide()</code>를 사용하면 된다.</p>

<p>먼저 사용할 프래그먼트들을 모두 추가해준다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">transaction</span> <span class="p">=</span> <span class="n">supportFragmentManager</span><span class="p">.</span><span class="nf">beginTransaction</span><span class="p">()</span>
<span class="n">transaction</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span>
<span class="o">..</span><span class="p">.</span>
</code></pre></div></div>

<p>그리고 사용할 프래그먼트만 <code class="highlighter-rouge">show</code>하고 나머지는 <code class="highlighter-rouge">hide</code>한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">transaction</span><span class="p">.</span><span class="nf">show</span><span class="p">(</span><span class="n">fragmentToUse</span><span class="p">)</span>
<span class="n">transaction</span><span class="p">.</span><span class="nf">hide</span><span class="p">(</span><span class="n">fragmentNotForUse</span><span class="p">)</span>
<span class="o">..</span><span class="p">.</span>
<span class="n">transaction</span><span class="p">.</span><span class="nf">commit</span><span class="p">()</span>
</code></pre></div></div>

<p>프래그먼트가 숨겨져도 마치 최상단에 있는 것과 같이 행동한다.
UI만 사라졌을 뿐이지 생명주기상으로는 <code class="highlighter-rouge">onPause</code>도 실행되지 않은 상태이다.
따라서 프래그먼트의 정보가 그대로 보존됨은 물론이고, 탭 사이에서 아주 빠른 전환이 가능해진다.</p>

<h2 id="목표-달성">목표 달성</h2>

<p>처음부터 목표를 세우고 한 건 아니지만, 어쩌다 보니 마음에 안 들었던 부분이 해결되었다.</p>

<p>프래그먼트를 잠시 숨기는게 만능은 아니다. 하지만 이 상황에서는 적절한 해법인 것 같다.</p>

<blockquote>
  <p>모든 상황에 적절한 해답은 없지만 특정 상황에 맞는 해답은 있다.</p>
</blockquote>
:ET