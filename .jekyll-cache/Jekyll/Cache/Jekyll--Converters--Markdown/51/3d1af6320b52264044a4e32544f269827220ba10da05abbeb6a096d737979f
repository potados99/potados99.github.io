I"<p><a href="https://www.acmicpc.net/problem/17825">백준 문제 페이지</a></p>

<p><a href="https://github.com/potados99/ps-study/blob/master/17825.cpp">풀이 소스코드</a></p>

<h2 id="들어가며">들어가며</h2>

<p>푸는 데에 3일 걸렸다. 문제가 불친절한건지 아니면 내가 잘못 이해한건지, 시키는대로 만들지 않아서 푸는 데에 꽤나 오래 걸렸다. 한참 삽질했다.</p>

<h2 id="문제-파악">문제 파악</h2>

<p>문제를 열자 마자 뜬금없이 이상한 주사위판 같은게 튀어나온다.
<img src="/assets/images/dice_map.png" alt="wtf is this" /></p>

<p>말이 있고, 주사위를 던져 나온 수 만큼 말을 이동시킨다. 말은 총 네 개가 있고, 주사위를 던져서 나온 수 10개가 미리 주어진다.</p>

<p>이때 이동시킬 말들을 적절히 선택해서 네 개 말이 얻은 점수의 합이 최대가 되도록 해야 한다.</p>

<p>요약하자면:</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Depth-first_search">깊이 우선 탐색(DFS)</a>을 활용하는</li>
  <li>시뮬레이션 문제다.</li>
</ul>

<h2 id="1차-시도">1차 시도</h2>

<h3 id="큰-틀">큰 틀</h3>

<p>일단 게임의 정보를 가지는 객체를 둔다. 그 객체는 맵 정보와 현재 플레이어의 정보를 가지고 있다.</p>

<h3 id="맵-만들기">맵 만들기</h3>

<p>어떻게 풀어야 할 지보다 어떤 자료 구조를 사용할까가 먼저 떠올랐다. 그래서 맵을 먼저 만들었다.</p>

<p>일단 기본적으로 맵은 여러 개의 노드로 이루어진다. 각 노드는 정수로 된 값을 가지며, 최대 두 개의 다음 노드를 가리킬 수 있다. 연결 리스트의 그것과 매우 유사한 구조이다.</p>

<p>처음에는 모든 노드를 만들고(힙에 할당) 그 포인터를 변수에 넣어둔 뒤, 그것들끼리 이어 맵을 완성하려 했다. 그런데 이렇게 되면 몇 가지 문제가 생긴다:</p>

<ul>
  <li>맵 변경에 유연하지 않음(사실 여기서는 크게 문제되지 않음).</li>
  <li>변수 이름 짓는 데에 문제가 생김(중복되는 숫자가 존재함).</li>
  <li>코드의 양이 폭발적으로 증가.</li>
  <li>못생김.</li>
</ul>

<p>그래서 생각해낸 방법은 다음과 같다:</p>

<blockquote>
  <p><strong>먼저 시작 노드를 만들고, 그 노드에 같은 성질을 가지는 노드들을 주욱 이어 붙여준다.</strong></p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 노드를 하나 만들고,</span>
<span class="n">node</span> <span class="o">*</span><span class="n">start_node</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// 그 노드를 시작으로 주우욱 붙여준다.</span>
<span class="n">node</span> <span class="o">*</span><span class="n">node10</span> <span class="o">=</span> <span class="n">attach</span><span class="p">(</span><span class="n">start_node</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">});</span>
</code></pre></div></div>

<p>이런 식으로 만들어주는 것이다.</p>

<p>기본 발상은 위와 같다. 이제 디테일을 더해보자.</p>

<p>노드는 <strong>검은 노드</strong>와 <strong>파란 노드</strong> 로 나뉘어지며 파란 노드의 다음 길은 <strong>빨간 길</strong>과 <strong>파란 길</strong> 로 나뉘어진다.</p>

<p>맵에 등장하는 색상은 <code class="highlighter-rouge">enum color</code>를 사용하여 정의했다:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">color</span> <span class="p">{</span>
    <span class="n">black</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">red</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>
</code></pre></div></div>

<p>노드는 <code class="highlighter-rouge">값</code>, <code class="highlighter-rouge">색상</code>, <code class="highlighter-rouge">다음노드(일반)</code>, <code class="highlighter-rouge">다음노드(특별)</code> 속성을 가진다:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="kt">int</span>             <span class="n">num</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">color</span>      <span class="n">color</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span>     <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span>     <span class="o">*</span><span class="n">special</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">다음 노드(일반)</code>은 검은 노드에서 다음 노드로 이어지는 <strong>빨간 길</strong> 에 있는 노드를 뜻하며, <code class="highlighter-rouge">다음 노드(특별)</code>은 파란 노드에서 다음 노드로 이어지는 두 길 중 <strong>파란 길</strong> 에 있는 노드를 뜻한다.</p>

<p>맵의 시작과 끝을 담은 맵 정보는 다음과 같이 정의했다:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">map</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span>    <span class="o">*</span><span class="n">start</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span>    <span class="o">*</span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>아무런 정보가 없는 시작 노드는 존재하지만 <strong>별도의 끝 노드는 만들지 않았다.</strong> 현재 노드가 <code class="highlighter-rouge">null</code>이 아니라면 끝에 도달하지 않은 것이다.</p>

<h3 id="플레이어-만들기">플레이어 만들기</h3>

<p><img src="/assets/images/trojan_horse.jpg" alt="트로이 목마" /></p>

<p>문제에서는 말이라 써있지만 <strong>플레이어</strong> 라는 단어가 더 편했다.</p>

<p>이 게임에는 플레이어가 넷 존재한다. 각 플레이어는 <code class="highlighter-rouge">현재 위치</code>와 <code class="highlighter-rouge">총점</code>, <code class="highlighter-rouge">종료 여부</code> 속성을 가진다:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">player</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span>     <span class="o">*</span><span class="n">current</span><span class="p">;</span>
    <span class="kt">int</span>             <span class="n">score</span><span class="p">;</span>
    <span class="n">bool</span>            <span class="n">finished</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="게임-정보-만들기">게임 정보 만들기</h3>

<p>이 모든 정보를 전역변수로 두기는 좀 그렇고, <code class="highlighter-rouge">context</code> 구조체로 정리했다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_context</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">map</span>     <span class="o">*</span><span class="n">map</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">player</span>  <span class="o">*</span><span class="n">players</span><span class="p">[];</span> <span class="c1">// 이 부분은 틀렸다. 아래에서 다루겠음.</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="스코어링">스코어링</h3>

<p>1차 시도까지만 해도 문제를 잘못 이해해서 점수 집계 방식 자체를 오해했다. 무려 이동하는 매 칸마다 점수를 더해주었다. 그러니까, 2부터 4, 6을 거쳐 10까지 3칸을 이동하면, 4 + 6 + 10점을 총계에 더한 것이다.</p>
<blockquote>
  <p>-&gt; 이동을 마쳤을 때에 그 도착지 숫자만 더해야 했다.</p>
</blockquote>

<p>또다른 큰 실수는 점수의 최댓값을 구하라는 것이 가장 점수 높은 플레이어의 점수를 구하라는 것인 줄 알고 플레이어 점수의 최댓값만 구한 것이다.</p>
<blockquote>
  <p>-&gt; 모든 플레이어의 총합을 더해야 했다.</p>
</blockquote>

<h3 id="dfs">DFS</h3>

<p>제일 중요한 부분 중 하나인데, 주사위판은 사실 부차적인 부분이다. 이 문제의 핵심은, <strong>10</strong> 개의 수를 플레이어들에게 분배하는 모든 경우의 수에 대해 실험을 해보는 것이다.</p>

<p>그러니까, 다음 경우들이 있을 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 0 0 0 0 0 0 0 0 0 -&gt; 10번의 이동 모두 0번이 함.
0 0 0 0 0 0 0 0 0 1 -&gt; 9번의 이동을 0번이, 1번의 이동을 1번이 함.
</code></pre></div></div>

<p>0부터 3 사이에서(총 네 명의 플레이어) 중복을 허용해 10 번을 뽑는 모든 경우의 수를 찾아야 한다.</p>

<p>코드는 이렇게 작성했다:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="n">context</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>

<span class="p">...</span>

<span class="c1">// 이게 본체</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">selected</span><span class="p">,</span> <span class="n">callback</span> <span class="n">on_pick</span><span class="p">,</span> <span class="n">context</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 각 경우에 대해 이 함수가 호출됨.</span>
        <span class="n">on_pick</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">selected</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">selected</span><span class="p">,</span> <span class="n">on_pick</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 이게 wrapper</span>
<span class="kt">void</span> <span class="nf">for_each_permutation</span><span class="p">(</span><span class="n">callback</span> <span class="n">on_pick</span><span class="p">,</span> <span class="n">context</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">},</span> <span class="n">on_pick</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">dfs</code> 함수가 비대해지는 것이 싫어 함수 포인터를 사용해 람다식을 흉내내었다.</p>

<h2 id="망했다">망했다!</h2>

<p>1차 시도는 거하게 망했다. 테스트 케이스조차 절반도 못 맞았다. 이게 다 문제를 잘 안 읽어서 그렇다.</p>

<h2 id="문제-제대로-파악하기">문제 제대로 파악하기</h2>

<p>문제를 보면 일단 이렇게 써있다.</p>
<blockquote>
  <p>말이 이동을 마칠때마다 칸에 적혀있는 수가 점수에 추가된다.</p>
</blockquote>

<p>말이 칸을 밟을 때가 아니라, 이동을 마쳤을 때에만 점수가 올라간다..!</p>

<p>그리고</p>
<blockquote>
  <p>이동하려고 하는 칸에 말이 이미 있는 경우에는 그 칸으로 이동할 수 없다.</p>
</blockquote>

<p>도착지에 말이 있으면 그냥 이동 자체를 하면 안된다!</p>

<p>또..</p>
<blockquote>
  <p>주사위에서 나올 수 10개를 미리 알고있을때, 얻을 수 있는 점수의 최댓값을 구해보자.</p>
</blockquote>

<p>점수의 최댓값이라는 것이, 네 플레이어 점수의 합이었다.</p>

<h2 id="2차-시도삽질">2차 시도(삽질)</h2>

<p>맵은 아무리 봐도 완성이어서 그냥 놓아 두었다.</p>

<h3 id="스코어링-1">스코어링</h3>

<p>이동 함수를 이렇게 짰다!</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">move</span><span class="p">(</span><span class="n">context</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">player_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how_many</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 당연히 걸러야 할 케이스들.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">how_many</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">players</span><span class="p">[</span><span class="n">player_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">players</span><span class="p">[</span><span class="n">player_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// 플레이어는 player_index에 의해 확정됨.</span>
    <span class="n">player</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">players</span><span class="p">[</span><span class="n">player_index</span><span class="p">];</span>

    <span class="c1">// 커서가 혼자 미리 가서 판단하고,</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">;</span>

    <span class="c1">// 처음 이동은 루프 진입 전에 한다.</span>
    <span class="c1">// 노드 색상에 따라 처음 이동 방향이 갈리기 때문에 다르게 처리해준다.</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">blue</span><span class="p">)</span> <span class="o">?</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">special</span> <span class="o">:</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

    <span class="c1">// 한 칸 왔으니 1 빼준다.</span>
    <span class="n">how_many</span><span class="o">--</span><span class="p">;</span>

    <span class="c1">// 커서 혼자서 다음으로 이동</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">how_many</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 만약 끝까지 왔으면</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 표시해주고</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">finished</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="c1">// 이동을 종료!</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 커서가 미리 간 그곳에 아무도 없으면 valid가 true이다.</span>
    <span class="n">bool</span> <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">how_many_are_there</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cursor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// valid 여부에 따라 점수와 이동 처리를 해준다.</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">score</span> <span class="o">+=</span> <span class="n">valid</span> <span class="o">?</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">?</span> <span class="n">cursor</span> <span class="o">:</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="또-망했다">또 망했다!</h2>

<h3 id="런타임-에러-세그먼트-오류">런타임 에러? 세그먼트 오류?</h3>

<p>자신있게 제출했는데 채점하다가 30%대 즈음에서 <strong>틀렸습니다</strong> 가 뜨는 것이다.</p>

<p>틀림없이 잘 구현했고, 맵도 원하는대로 완성되었고 완벽한데 왜 안되나 싶었다.</p>

<p>그래서 다른 곳에서 정답 소스코드를 구해서 <strong>테스트 케이스 무작위 대입</strong> 을 통해 틀린 케이스를 찾아내기로 했다.</p>

<p>쉘을 켜고, 테스트 스크립트를 작성하고, 구현물을 컴파일해서 실행을 하는데…</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Segmentation fault (core dumped)
</code></pre></div></div>

<p><img src="/assets/images/wtf.jpg" alt="wtf" /></p>
<blockquote>
  <p>WTF</p>
</blockquote>

<p>Xcode에서는 잘만 실행되던 것이 쉘에서 직접 실행하니까 바로 뻗는 것이다. 혹시나 싶어 Xcode에서 컴파일한 바이너리를 직접 <code class="highlighter-rouge">./바이너리</code>로 실행해보니 역시나 뻗는 것이다.</p>

<p>이게 무슨 일인가 싶어 <code class="highlighter-rouge">gdb a.out</code>으로 살펴보려 했는데…</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>not in executable format: File format not recognized
</code></pre></div></div>

<p><img src="/assets/images/bullshit.gif" alt="bullshit" /></p>
<blockquote>
  <p>gdb가 개소리를 한다…</p>
</blockquote>

<p>이것 가지고 씨름하기 싫어서 코드를 유심히 살펴보다가 문제를 찾았다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_context</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">map</span>     <span class="o">*</span><span class="n">map</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">player</span>  <span class="o">*</span><span class="n">players</span><span class="p">[];</span> <span class="c1">// 요거요거</span>
<span class="p">}</span>
</code></pre></div></div>

<p>포인터의 배열을 만든다고 저렇게 선언해놓았는데, 크기를 안 써주니 사실상 아래와 똑같았던 것이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_context</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">map</span>     <span class="o">*</span><span class="n">map</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">player</span>  <span class="o">**</span><span class="n">players</span><span class="p">;</span> <span class="c1">// *players[]랑 똑같음.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그렇다… 할당도 안 된 공간에 무턱대고 대입을 한 것이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">context</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">new</span> <span class="n">context</span><span class="p">;</span>

<span class="p">...</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">player</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">new</span> <span class="n">player</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">players</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// 거긴 네가 들어갈 곳이 아니라구!</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">c-&gt;players</code>의 크기는 내가 원하던 <code class="highlighter-rouge">8*4</code>바이트가 아니라 그냥 <code class="highlighter-rouge">8</code>바이트인데, <code class="highlighter-rouge">8*i</code> 영역에 접근해서 값을 써버리니, <code class="highlighter-rouge">map</code>의 다른 노드에 그 값이 덮어씌워진 것이다!</p>

<p>심지어 메모리 할당은 운영체제가 알아서 관리하기 때문에 그 겹치는 영역이 어디인지도 모른다. 그래서 Xcode로 실행할 때에 랜덤하게 에러가 발생했던 것이다.</p>

<p>그래서, 이렇게 고쳐서 해결했다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_context</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">map</span>     <span class="o">*</span><span class="n">map</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">player</span>  <span class="o">*</span><span class="n">players</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="문제를-잘못-이해했다">문제를 잘못 이해했다</h3>

<p>간신히 구동에 성공해서 테스트를 시작할 수 있었다. 밤새 실행해서 틀린 테스트 케이스를 186개 구했다.</p>

<p>틀린 경우를 보면, 모두 정답보다 조금 숫자가 크게 나오는 경우였다.</p>

<p>일단 테스트 케이스 <strong>1 2 1 4 1 4 3 2 2 1</strong> 을 가지고 분석을 시작했다.</p>

<p>정답 판정받은 코드에서는 이동한 플레이어를 표시해보면 아래와 같이 나온다:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 0 0 0 0 0 0 0 0 1
</code></pre></div></div>

<p>그런데 내가 짠 코드에서는 이렇게 나온다</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 1 0 1 1 1 1 1 1 1
</code></pre></div></div>

<p>내가 짠 코드가 정답보다 2 큰 답을 낸다.</p>

<p>다른 케이스도 분석해보니 한 가지 공통점이 있었다.</p>

<p><strong>최댓값이 나오는 케이스에서, 플레이어가 이동을 시도했으나 그 자리에 이미 다른 플레이어가 있어서 이동하지 못하는 경우가 있었다.</strong></p>

<p>문제를 다시 보니</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>이동하려고 하는 칸에 말이 이미 있는 경우에는 그 칸으로 이동할 수 없다.
</code></pre></div></div>

<p>이렇게 써있는데, 분명히 잘 지켜서 코딩했는데 틀렸단다.</p>

<p>도저히 안되겠어서 스승님께 여쭈어 보니,</p>

<p><strong>'”이동하려고 하는 칸에 말이 이미 있는 경우에는 그 칸으로 이동할 수 없”는 케이스는 한 턴으로 인정하지 말고 넘기’</strong> 라 하셨다.</p>

<p><del>아니 그런게 어딨어 문제 설명 왜 저렇게밖에 안돼있는데</del></p>

<h2 id="3차-시도-마지막-삽질">3차 시도 (마지막 삽질)</h2>

<h3 id="무효한-케이스-버리기">무효한 케이스 버리기</h3>

<p>일단 틀린 케이스가 감지되면 이동을 멈추고 다음 이동도 멈출 것을 <code class="highlighter-rouge">on_pick</code>(10개짜리 순열에 대해 적절히 이동을 실시하는 함수) 함수에 알려야 한다.</p>

<p>반환값을 사용해 전달하기로 했다.</p>

<p><code class="highlighter-rouge">move</code>함수에서 바뀐 부분은 다음과 같다:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * return: keep of not
 */</span>
<span class="n">bool</span> <span class="nf">move</span><span class="p">(</span><span class="n">context</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">player_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how_many</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="c1">// 이 부분이 달라졌다. valid하지 않으면 그냥 끝낸다.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">how_many_are_there</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cursor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">p</span><span class="o">-&gt;</span><span class="n">score</span> <span class="o">+=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">=</span> <span class="n">cursor</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>저 함수를 호출하는 쪽에서는 아래처럼 처리했다:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">do_on_pick</span><span class="p">(</span><span class="n">context</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">selected</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="c1">// 하나라도 false가 뜨면 즉시 해당 케이스를 종료하고 반환한다.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">move</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">selected</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
            <span class="n">reset</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="kt">int</span> <span class="n">local_max</span> <span class="o">=</span> <span class="n">get_score_sum</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">local_max</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
        <span class="n">max</span> <span class="o">=</span> <span class="n">local_max</span><span class="p">;</span>

    <span class="n">reset</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="해결">해결</h3>

<p>결국 해결했다.</p>

<p><img src="/assets/images/17825_assign.png" alt="정답" /></p>

<h2 id="후기">후기</h2>

<p>무척이나 고통스러웠다…</p>

<p>정말이지 갈 길이 멀었다. 문제를 보자 마자 시간 안에 푸는 것은 아직은 많이 힘든 것 같다.</p>

<p>오랜만에 메모리와 포인터에 대해 생각해 볼 만한 기회였다.</p>

<h2 id="스페셜-땡스-투">스페셜 땡스 투</h2>

<p><a href="https://github.com/ryuspace">스승님</a> 도움 주셔서 감사합니다 <del>이렇게 쓰는거 맞죠..?</del></p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</a></li>
</ul>
:ET