I"X><blockquote>
  <p>이 글에서 잘 썼다 싶은 부분은 stack overflow의 <a href="https://stackoverflow.com/questions/4209641/absolute-vs-explicit-relative-import-of-python-module">어느 답변</a>과 <a href="https://www.python.org/dev/">python 공식 문서</a>에서 발췌한 것이며, 그렇지 않은 부분은 직접 작성한 것입니다.</p>
</blockquote>

<h2 id="서론">서론</h2>

<p>프로그램을 짜다 보면 feature와 무관한 것들을 하나로 묶어 common이나 util로 정리하고 싶은 충동을 자주 느끼게 된다. python을 포함하여 쓸만한 프로그래밍 언어는 다른 프로그램 조각 또는 바이너리를 사용할 수 있게 설계되어 있다.</p>

<p>Python은 특이하다. 인터프리터 언어이기 때문에 사용자와 상호작용하는 스크립트처럼 사용할 수 있을 뿐만 아니라, 패키지 형태를 띠도록 설계하여 부분 모듈을 컴파일하여 실행하는 식으로 조금 정적으로 사용할 수도 있다.</p>

<p>프로젝트 구조가 복잡해지면 이 특징이 굉장히 혼란스럽게 다가올 수 있다.</p>

<h2 id="간단한-프로젝트에서">간단한 프로젝트에서</h2>

<p>프로젝트 디렉토리 구조가 다음처럼 생겼다고 하자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> pyproject
 ├── util.pyc
 └── runner.py
</code></pre></div></div>

<p>각 파일은 이렇게 생겼다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># util.py
</span>
 <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
     <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># runner.py
</span>
 <span class="kn">import</span> <span class="nn">util</span>

 <span class="k">print</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p>실행하면 3이 출력될 것이다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ python3 runner.py
 3
</code></pre></div></div>

<p>이대로라면 문제가 없다.</p>

<h2 id="조금-복잡한-프로젝트에서">조금 복잡한 프로젝트에서</h2>

<p>Python에서는 하나의 <code class="highlighter-rouge">.py</code> 파일이 모듈로 취급된다. 이러한 모듈이 모여서 패키지를 이룬다.</p>

<p>패키지의 구조는 파일 시스템의 디렉토리와 대응되는데, 이때 디렉토리 아래에 <code class="highlighter-rouge">__init__.py</code>라는 파일이 있어야 python 패키지로 인식된다.</p>

<p>아래는 python 패키지의 예시이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> arithmetic
 ├── __init__.py
 ├── decimal.py
 ├── integer.py
 └── util.py
</code></pre></div></div>

<p><code class="highlighter-rouge">decimal.py</code>와 <code class="highlighter-rouge">integer.py</code>는 각각 <code class="highlighter-rouge">util.py</code>를 import하여 사용한다.</p>

<p>이 <code class="highlighter-rouge">arithmetic</code> 패키지를 사용하는 프로젝트를 만든다고 가정해보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>myproject
├── arithmetic
│   ├── __init__.py
│   ├── decimal.py
│   ├── integer.py
│   └── util.py
└── runner.py
</code></pre></div></div>

<p><code class="highlighter-rouge">runner.py</code>는 이렇게 생겼다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># runner.py
</span>
 <span class="kn">from</span> <span class="nn">arithmetic</span> <span class="kn">import</span> <span class="n">decimal</span>

 <span class="k">print</span><span class="p">(</span><span class="s">"3 / 2 is "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">decimal</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">arithmetic</code> 패키지 내의 모듈들은 이렇게 생겼다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># decimal.py
</span>
 <span class="kn">import</span> <span class="nn">util</span>

 <span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
 	<span class="s">"""
 	&gt;&gt;&gt; div(3, 2)
 	1.5
 	"""</span>

 	<span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
 	<span class="n">util</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s">"dividing..."</span><span class="p">)</span>

 	<span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># integer.py
</span>
 <span class="kn">import</span> <span class="nn">util</span>

 <span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
 	<span class="s">"""
 	&gt;&gt;&gt; div(3, 2)
 	1
 	"""</span>

 	<span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">//</span> <span class="n">b</span>
 	<span class="n">util</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s">"dividing..."</span><span class="p">)</span>

 	<span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># util.py
</span>
 <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
	<span class="k">pass</span>
</code></pre></div></div>

<p>각 모듈에는 <code class="highlighter-rouge">doctest</code>를 위해 test docstring을 달아놓았다.</p>

<p>실행해보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ python runner.py
 3 / 2 is 1
</code></pre></div></div>

<p>잘 실행된다.</p>

<p>python3으로도 실행해보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ python3 runner.py
 Traceback (most recent call last):
  File "runner.py", line 1, in &lt;module&gt;
    from arithmetic import decimal
  File "/Users/potados/Temp/pyimport/arithmetic/decimal.py", line 1, in &lt;module&gt;
    import util
ModuleNotFoundError: No module named 'util'
</code></pre></div></div>

<p>에러가 뜬다. <code class="highlighter-rouge">util</code> 모듈이 없단다. 바로 옆에 있는데?</p>

<p><img src="/assets/images/bullshit.gif" alt="bullshit" /></p>
<blockquote>
  <p>개소리 집어치워</p>
</blockquote>

<p>찾아보니 <a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a>에 이런게 있더라.</p>

<blockquote>
  <p>Explicit relative imports are an acceptable alternative to absolute imports.  <br />
Implicit relative imports should never be used and have been removed in Python3.</p>
</blockquote>

<p>Python 3에서는 <strong>암묵적인 상대경로 import가 안된다</strong> 는 것이다.</p>

<p>Python 2는 주어진 import 경로가 상대경로일 것이라고 암묵적으로 해석하고 같은 디렉토리에서 이를 찾는다.</p>

<p>반면에 python 3는 import 경로가 <code class="highlighter-rouge">.</code>으로 시작하지 않았기 때문에 절대경로라고 생각하고 엉뚱한 곳에서 찾은 것이다.</p>

<p>그렇다면 상대경로를 넣어주면 되지 않을까.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># decimal.py
</span>
 <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">util</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ python3 runner.py
 3 / 2 is 1.5
</code></pre></div></div>

<p>잘 된다.</p>

<p>그런데 어쩌다 <code class="highlighter-rouge">decimal.py</code>의 구현을 바꿀 일이 생겨 <code class="highlighter-rouge">doctest</code>를 진행해야 하는 상황이 왔다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ python3 -m doctest decimal.py   
 Traceback (most recent call last):
   File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/runpy.py", line 193, in _run_module_as_main
    "__main__", mod_spec)
   File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/runpy.py", line 85, in _run_code
    exec(code, run_globals)
   File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/doctest.py", line 2786, in &lt;module&gt;
    sys.exit(_test())
   File "/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/doctest.py", line 2774, in _test
    m = __import__(filename[:-3])
   File "/Users/potados/Temp/pyimport/arithmetic/decimal.py", line 1, in &lt;module&gt;
    from . import util
 ImportError: attempted relative import with no known parent package
</code></pre></div></div>

<p>요약하자면 <em>부모 패키지도 모르는데(=스크립트로 직접 실행하는데) 감히 상대경로 import를 시도했다</em> 라는 뜻이다.</p>

<p><a href="https://www.python.org/dev/peps/pep-0338/">PEP 338</a>과 <a href="https://www.python.org/dev/peps/pep-0366/">PEP 366</a>에 의하면 상대경로 import를 하려면 해당 python 파일을 모듈로써 import해야 한다고 한다.</p>

<p>즉, <strong>relative import를 포함한 python 모듈은 스크립트로 직접 실행할 수 없다.</strong></p>

<p>Python의 창시자, Guido가 이렇게 말했다.</p>
<blockquote>
  <p>The only use case seems to be running scripts that happen to be living inside a module’s directory, which I’ve always seen as an antipattern. To make me change my mind you’d have to convince me that it isn’t.</p>
</blockquote>

<p>패키지 안에 있는 모듈을 스크립트로 실행하는 것은 안티패턴이라고 한다.</p>

<h2 id="둘다-포기-못해">둘다 포기 못해</h2>

<p>정리하면 다음과 같다.</p>

<ul>
  <li><strong>상대경로 import를 포함한 python 모듈은 단독 실행이 불가능하다.</strong></li>
  <li><strong>패키지 내에서 절대경로 import는 쉽지 않다.</strong></li>
</ul>

<p>패키지 안에 들어있는 모듈을 단독으로 실행하는 것이 python 철학에는 맞지 않는 모양인 것 같은데, 모듈만 실행하고 싶을 때가 종종 있다. 당장 위처럼 <code class="highlighter-rouge">doctest</code>를 모듈 단위로 돌리고 싶을 때가 있다.</p>

<p>방법이 있다.</p>

<p>Python에는 <code class="highlighter-rouge">__name__</code>이라는 특별한 변수가 있다. 이는 최상위 스코프의 이름을 나타내는데, 현재 모듈의 실행 상태를 판단하는 데에 사용할 수 있다.</p>

<p>예를 들어서, 스크립트로 직접 실행할 때에만 어떤 작업을 수행하고 싶다면 이렇게 하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">def</span> <span class="nf">blahblah</span><span class="p">():</span>
     <span class="o">...</span>

 <span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
     <span class="c1"># Do something only when directly executed as a script.
</span></code></pre></div></div>

<p>직접 실행할 때에는 <code class="highlighter-rouge">__name__</code>이 <code class="highlighter-rouge">__main__</code>이 된다. 다른 경우에는 어떨까.</p>

<p>잠시 <code class="highlighter-rouge">decimal.py</code>의 코드를 수정해보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># from . import util
</span>
 <span class="k">print</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

 <span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
 	<span class="s">"""
 	&gt;&gt;&gt; div(3, 2)
 	1.5
 	"""</span>

 	<span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
    <span class="c1"># util.log("dividing...")
</span>
 	<span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>해당 모듈이 실행되거나 import되는 즉시 <code class="highlighter-rouge">__name__</code>이 출력될 것이다.</p>

<p>결과는 다음과 같다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">실행 방법</th>
      <th style="text-align: center">명령</th>
      <th style="text-align: center"><code class="highlighter-rouge">__name__</code> 값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">직접 실행</td>
      <td style="text-align: center"><code class="highlighter-rouge">python3 arithmetic/decimal.py</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">__main__</code></td>
    </tr>
    <tr>
      <td style="text-align: center">doctest로 실행</td>
      <td style="text-align: center"><code class="highlighter-rouge">python3 -m doctest arithmetic/decimal.py</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">decimal</code></td>
    </tr>
    <tr>
      <td style="text-align: center">패키지 내부에서 import</td>
      <td style="text-align: center"><code class="highlighter-rouge">python3 runner.py</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">arithmetic.decimal</code></td>
    </tr>
  </tbody>
</table>

<p>이 중 직접 실행하는 경우와 doctest로 실행하는 경우에는 절대경로 import를, 그렇지 않은 경우(=패키지 내부 import)의 경우에는 상대경로 import를 해주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span> <span class="ow">or</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"decimal"</span><span class="p">:</span>
 	<span class="kn">import</span> <span class="nn">util</span>
 <span class="k">else</span><span class="p">:</span>
 	<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">util</span>
</code></pre></div></div>

<h2 id="reference">Reference</h2>

<ul>
  <li>https://stackoverflow.com/questions/16981921/relative-imports-in-python-3</li>
</ul>
:ET